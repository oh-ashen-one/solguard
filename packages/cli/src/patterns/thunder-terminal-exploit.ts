// SOL741: Thunder Terminal Exploit Pattern (Dec 2023 - $240K)
// Based on the Thunder Terminal exploit where MongoDB injection led to session hijacking

import type { ParsedRust } from '../parsers/rust.js';
import type { Finding } from '../commands/audit.js';
import type { PatternInput } from './index.js';

/**
 * Thunder Terminal Exploit Patterns (December 2023)
 * 
 * Thunder Terminal was exploited through a MongoDB injection vulnerability
 * that allowed attackers to hijack user sessions and drain funds. The attack
 * was detected and halted within 9 minutes.
 * 
 * Key vulnerabilities:
 * 1. NoSQL/MongoDB injection in third-party services
 * 2. Session token security flaws
 * 3. Missing input sanitization on external data
 * 4. Insufficient session validation
 */

export function checkThunderTerminalExploit(parsed: ParsedRust): Finding[] {
  const findings: Finding[] = [];

  // Check for database query patterns without sanitization
  const dbQueryPatterns = [
    /mongodb|mongoose|mongo_client/i,
    /find_one|find_many|update_one/i,
    /query.*\{|collection\./i,
  ];

  const sanitizationPatterns = [
    /sanitize|escape|validate_input/i,
    /regex.*safe|safe.*regex/i,
    /input_check|param_check/i,
  ];

  for (const func of parsed.functions) {
    const content = func.content.toLowerCase();
    
    const hasDbQuery = dbQueryPatterns.some(p => p.test(content));
    
    if (hasDbQuery) {
      const hasSanitization = sanitizationPatterns.some(p => p.test(content));
      
      if (!hasSanitization) {
        findings.push({
          id: 'SOL671',
          severity: 'critical',
          title: 'Thunder-style NoSQL Injection Risk',
          description: `Function '${func.name}' performs database queries without visible input sanitization`,
          location: func.location,
          recommendation: 'Always sanitize user inputs before database queries. Use parameterized queries and validate input types.',
        });
      }
    }
  }

  // Check for session management patterns
  const sessionPatterns = [
    /session_token|session_id|auth_token/i,
    /jwt|bearer|access_token/i,
    /login_session|user_session/i,
  ];

  for (const func of parsed.functions) {
    const content = func.content.toLowerCase();
    
    const handlesSession = sessionPatterns.some(p => p.test(content));
    
    if (handlesSession) {
      // Check for session validation
      if (!/verify_session|validate_token|check_expiry/i.test(content)) {
        findings.push({
          id: 'SOL672',
          severity: 'high',
          title: 'Session Token Without Validation',
          description: `Function '${func.name}' handles session tokens without proper validation`,
          location: func.location,
          recommendation: 'Implement session token verification, expiry checks, and signature validation for all authenticated endpoints.',
        });
      }

      // Check for secure session storage
      if (/plain|raw|unencrypted/i.test(content)) {
        findings.push({
          id: 'SOL673',
          severity: 'high',
          title: 'Insecure Session Token Storage',
          description: `Function '${func.name}' may store session tokens insecurely`,
          location: func.location,
          recommendation: 'Store session tokens encrypted at rest. Use secure, httpOnly cookies and implement proper session rotation.',
        });
      }
    }
  }

  // Check for withdrawal authorization
  const withdrawPatterns = [
    /withdraw|transfer.*fund|send.*token/i,
    /sign.*transaction|submit.*tx/i,
  ];

  for (const func of parsed.functions) {
    const content = func.content.toLowerCase();
    
    const handlesWithdraw = withdrawPatterns.some(p => p.test(content));
    
    if (handlesWithdraw) {
      // Check for multi-factor or additional verification
      if (!/two_factor|2fa|additional_auth|confirm/i.test(content)) {
        findings.push({
          id: 'SOL674',
          severity: 'high',
          title: 'Withdrawal Without Additional Authorization',
          description: `Function '${func.name}' processes withdrawals without multi-factor verification`,
          location: func.location,
          recommendation: 'Require additional authorization (2FA, email confirmation, withdrawal delay) for fund movements.',
        });
      }
    }
  }

  return findings;
}

// Export combined check
export function checkThunderStyleExploits(input: PatternInput): Finding[] {
  if (!input.rust) return [];
  return checkThunderTerminalExploit(input.rust);
}
